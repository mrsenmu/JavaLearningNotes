# 一、数据库概述与MySQL安装

## 1、数据库概述

### Ⅰ 为什么要使用数据库

- **持久化(persistence)**：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，**数据持久化意味着将内存中的数据保存到硬盘上加以”固化”**，而持久化的实现过程大多通过各种关系数据库来完成。
- **持久化的主要作用是**将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。

### Ⅱ **数据库与数据库管理系统**

1. **数据库相关概念**

   | **DB**：数据库（Database）                                   |
   | ------------------------------------------------------------ |
   | 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。 |
   | **DBMS：数据库管理系统（Database Management System）**       |
   | 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。 |
   | **SQL：结构化查询语言（Structured Query Language）**         |
   | 专门用来与数据库通信的语言。                                 |

2. **数据库与数据库管理系统的关系**

   - 数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。
   
   - 数据库管理系统、数据库和表的关系如图所示：
   
     ![image-20220211155258862](https://cdn.jsdelivr.net/gh/mrsenmu/JavaLearningNotes/images/mysql/202202161657350.png)
   
   - **常见的数据库管理系统排名(DBMS)**
   
     - 目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、 Sybase、Informix这几种。
     - 以下是2021年**DB-Engines Ranking** 对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名: **https://db-engines.com/en/ranking**）。
     
   - **常见数据库介绍**
     
     - **Oracle**：第一个商用的 RDBMS（关系型数据库管理系统）。
     - **SQL Server**：QL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用。
     - **DB2**：IBM公司的数据库产品,收费的。常应用在银行系统中。
     - **PostgreSQL**：稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。
     - **SyBase**：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。
     - **SQLite**：嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。
     - **informix**：IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。
   
3. **MySQL介绍**

   1. **概述**
      - MySQL是一个开放源代码的关系型数据库管理系统由瑞典MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的 No.1。
      - MySQL6.x 版本之后分为社区版和商业版。
      - MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
      - MySQL是可以定制的，采用了GPL（GNU General Public License)协议，你可以修改源码来开发自己的MySQL系统。
      - MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。
      - MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。
   
   2. 为什么如此多的厂商要选用MySQL的原因：
      -  开放源代码，使用成本低。
      - 性能卓越，服务稳定。
      - 软件体积小，使用简单，并且易于维护。
      -  历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。
      -  许多互联网公司在用，经过了时间的验证。
   
   3. Oracle vs MySQL
      - Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。
      - MySQL 由于其**体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库**（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。
   
4.  **RDBMS 与 非RDBMS**

   从排名中我们能看出来，**关系型数据库**绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。

   **关系型数据库(RDBMS)**
   
   1.  **实质**
      - 关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）
      - 关系型数据库以**行(row)**和**列(column)**的形式存储数据，这一系列的行和列被称为**表(table)**，一组表组成了一个**库(database)**。
      - 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用**关系模型**。
      - SQL就是关系型数据库的查询语言。
   2. **优势**
      - **复杂查询** 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
      - **事务支持** 使得对于安全性能很高的数据访问要求得以实现。
   
   **非关系型数据库(非RDBMS)**
   
   1. **介绍**：
   
      **非关系型数据库**可看成传统关系型数据库的功能阉割版本，基于键值对存储数据，不需要经过SQL层的解析，**性能非常高**。同时，通过减少不常用的功能，进一步提高性能。相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。
   
   2. **有哪些**：
   
      （1）**键值型数据库**：键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，**优点**是**查找速度快**，在这方面明显优于关系型数据库，**缺点**是**无法**像关系型数据库一样使用**条件过滤**（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。键值型数据库典型的使用场景是作为内存缓存。**Redis**是最流行的键值型数据库。
   
      （2）**文档型数据库**：此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。**MongoDB** 是最流行的文档型数据库。
   
      （3）**搜索引擎数据库**：虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是**“倒排索引”**。典型产品：Solr、**Elasticsearch**、Splunk 等。
   
      （4）**列式数据库**：是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是**将数据按照列存储到数据库中**，这样做的**好处是可以大量降低系统的I/O，适合于分布式文件系统**，不足在于功能相对有限。典型产品：HBase等。
   
      （5）**图形数据库**：利用了**图这种数据结构存储了实体（对象）之间的关系**。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。
      图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。
   
   3. **NoSQL的演变**
   
      NoSQL 对 SQL 做出了很好的补充，比如**实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能**，非关系型数据库的功能就足够使用了。这种情况下，使用**性能更高、成本更低**的非关系型数据库当然是更明智的选择。比如：**日志收集、排行榜、定时器**等。
   
5.  **关系型数据库设计规则**

   - **表、记录、字段**

      - E-R（entity-relationship，实体-联系)模型中有三个主要概念是：**实体集、属性、联系集**。

      - 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。

      - ```
         ORM思想（Object Relational Mapping）体现：
         数据库中的一个表 <---> 面向对象语言中的一个类
         表中一行 <---> 类中的一个对象（或实体）
         表中一列 <---> 类中的一个字段、属性(field)
        ```

   - **表的关联关系**

      表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用**关系模型**来表示。**四种：一对一关联、一对多关联、多对多关联、自我引用。**

      1. **一对一关联（one-to-one）**
         - 在实际的开发中应用不多，因为一对一可以创建成一张表。
         - 如用户信息表可拆分成用户基本信息表和用户详情表。
         - 原则：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。
      2.  **一对多关系（one-to-many）**
         - 如商品分类表和商品信息表。一个分类对应多个商品。
         - 原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键。
      3. **多对多（many-to-many）**
         - 要表示多对多关系，必须**创建第三个表**，该表通常称为**联接表**，它将多对多关系划分为两个一对多关系。**将这两个表的主键都插入到第三个表中**。
         - 如：学生-课程、商品-订单、用户-角色等关系。
      4. **自我引用(Self reference)**
         - 如分类表中有id（主键）、parent_id(父级分类id)。

## 2、MySQL环境搭建（Windows环境）

详情可参考 [MySQL安装与卸载教程（Windows）](https://gitee.com/mrsenmu/JavaLearningNotes/blob/main/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(Windows).md)

# 二、SQL与SELECT的使用

## 1、SQL概述

### Ⅰ 背景

- 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化。
- SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言。与数据直接打交道 ，由 IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有 SQL-86 ，SQL-89 ， SQL-92 ， SQL-99 等标准。**SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。**
- 不同的数据库生产厂商都支持SQL语句，但都有特有内容。相当于，SQL规范（普通话），MySQL(Oracle、SQL server...)特有（方言）。

### Ⅱ SQL分类（三大类）

1. **DDL（Data Definition Languages 数据定义语言）**：这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建（CREATE）、删除（DROP）、修改（ALTER）数据库和数据表的结构。
2. **DML（Data Manipulation Language 数据操作语言）**：用于添加（INSERT）、删除（DELETE）、更新（UPDATE）和查询（SELECT）数据库记录，并检查数据完整性。其中，**SELECT是SQL语言的基础，最为重要**。
3. **DCL（Data Control Language 数据控制语言）**：用于定义数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 **GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT** 等。
4. 注意：因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：**DQL（数据查询语言）**。还有单独将 COMMIT 、 ROLLBACK 取出来称为**TCL （Transaction Control Language，事务控制语言）**。

### Ⅲ 常用的SQL标准

在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。

**SQL 有两个主要的标准，分别是 SQL92 和 SQL99** 。92 和 99 代表了标准提出的时间，SQL92 就是 92 年提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、 SQL:2011 和 SQL:2016 等其他的标准，[了解更多](https://modern-sql.com/standard)。

这么多标准，到底该学习哪个呢？**实际上最重要的SQL标准就是SQL92和SQL99**。一般来说 SQL92 的形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂，但可读性更强。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了1000 页。

实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满足日常工作的需求即可。

**SQL92和SQL99是经典的SQL标准，也分别叫做SQL-2和SQL-3标准。**也正是在这两个标准发布之后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言，还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使用。

## 2、SQL语言的规则与规范

### Ⅰ 基本规则

- SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进。每条命令以 ; 或 \g 或 \G 结束。
- 关键字不能被缩写也不能分行。
- 关于标点符号：
  - 必须保证所有的()、单引号、双引号是成对结束的。
  - 必须使用英文状态下的半角输入方式。
  - 字符串型和日期时间类型的数据可以使用单引号 ' ' 表示。
  - 列的别名，尽量使用双引号 " " ，而且不建议省略as。

### Ⅱ SQL大小写规范

- MySQL 在 **Windows** 环境下是大小写**不敏感**的。
- MySQL 在 **Linux** 环境下是大小写**敏感**的。
- **推荐采用统一的书写规范：**
  - **数据库名、表名、表别名、字段名、字段**别名等都**小写**。
  - **SQL 关键字、函数名、绑定变量**等都**大写**。

### Ⅲ 注释

```sql
单行注释：#注释文字(MySQL特有的方式)
单行注释：-- 注释文字(--后面必须包含一个空格。)
多行注释：/* 注释文字 */
```

### Ⅳ 命名规则

- 数据库、表名不得超过30个字符，变量名限制为29个。
- 必须只能包含 A–Z, a–z, 0–9, _共63个字符。
- 数据库名、表名、字段名等对象名中间不要包含空格。
- 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名。
- 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用着重号 `` (英文输入法，通常为左上角1号键左边)引起来。
- 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了。

### Ⅴ 数据导入指令

在命令行客户端登录mysql，使用source指令导入

```mysql
#导入
mysql> source d:\mysqldb.sq;
#查看表结构指令desc
mysql> desc table_name;
```

## 3、基本的SELECT语句

### Ⅰ SELECT

```mysql
SELECT 1; #没有任何子句
SELECT column_name1, column_name2,... FROM table_name #指定表、字段查询
SELECT * FROM table_name #查询指定表所有字段
```

注意：在生产环境下，不推荐直接使用 SELECT * 进行查询。是获取不需要的列数据通常会**降低查询和所使用的应用程序的效率**。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。

### Ⅱ 列的别名（AS 关键字）

- 重命名一个列，便于计算，紧跟列名，**在列名和别名之间加入关键字AS。可省略关键字AS**。
- **别名可使用双引号**，以便在别名中包含空格或特殊的字符并区分大小写。

```mysql
SELECT last_name AS name, commission_pct comm FROM employees;
SELECT last_name "Name", salary*12 "Annual Salary" FROM employees;
```

### Ⅲ 去重复行(关键字DISTINCT)

默认情况下，查询会返回全部行，包括重复行。

```mysql
#在SELECT语句中使用关键字DISTINCT去除重复行
SELECT name FROM students
```

注意：DISTINCT 需要放到所有列名的前面，否则报错；DISTINCT 其实是对后面所有**列名的组合**进行去重。这意味着组合中所有字段值都相同才算一条重复的数据而被去重。

### Ⅳ 空值参与运算

所有运算符或列值遇到null值，运算的结果都为null。

### Ⅴ 着重号

我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对``（着重号）引起来。

```mysql
mysql> SELECT * FROM ORDER; #报错
mysql> SELECT * FROM `ORDER`; #正常运行
```

### Ⅵ 查询常数

SELECT 查询还可以对常数进行查询。就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。

如下查询学生表时，增加一个常数字段class，值固定为1班。

```mysql
SELECT '1班' AS class, name FORM students
```

### Ⅶ 查询条件语句（WHERE）

```mysql
#语法 WHERE子句紧随 FROM子句
SELECT 字段1, 字段2,...
FROM 表名
WHERE 布尔表达式1 [AND[OR]] 布尔表达式2
```

注意：

- 在表中有相同列时，在列名之前加上表名前缀。
- 多个连接条件用AND关键字。
- **FROM关键字连接表时可以使用别名**，简化查询语句,提高查询效率。连接多个表时，调用同名列必须指明其所在的表。如：WHERE (别名1)表名1.id = (别名2)表名2.id。

## 4、运算符

### Ⅰ 算术运算符

算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行 加（+）、减（-）、乘（*）、除（/）和取模（%）运算。

| 运算符 | 作用         | 示例                          |
| ------ | ------------ | ----------------------------- |
| +      | 加法         | SELECT A+B                    |
| -      | 减法         | 计算两个值或表达式的差        |
| *      | 乘法         | SELECT A*B                    |
| /或DIV | 除法         | SELECT A/ B 或 SELECT A DIV B |
| %或MOD | 求模（取余） | SELECT A%B                    |

**注意**：

- **加减法**：整数与浮点数操作结果为浮点数；在MySQL中**+只表示数值相加**。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）。
- **乘除法**：整数乘、除以浮点数结果为浮点数；**一个数除以整数后，不管是否能除尽，结果都为一个浮点数**(保留小数点后4位)；MySQL中，一个数除以0为NULL。 

### Ⅱ 比较运算符

比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为**真则返回1**，比较的结果为**假则返回0**，其他情况则返回NULL。

比较运算符经常被用来作为SELECT查询语句的条件来使用（**WHERE关键字后面**），返回符合条件的结果记录。

| 运算符 | 作用     |
| ------ | -------- |
| =      | 等于     |
| <=>    | 安全等于 |
| <>(!=) | 不等于   |
| <      | 小于     |
| <=     | 小于等于 |
| >      | 大于     |
| >=     | 大于等于 |

注意：

- 比较字符串时MySQL比较的是每个字符串中字符的**ANSI编码**是否相等。
- 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。
- **如果等号（=）和不等号（<>和!=）两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL**。
- **安全等于运算符** 安全等于运算符（<=>）与等于运算符（=）的作用是相似的， **唯一的区别 是‘<=>’可以用来对NULL进行判断**。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。

### Ⅲ 逻辑运算符

逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL（**表达式中存在NULL时结果都为NULL**）。 

MySQL中支持4种逻辑运算符如下：

| 运算符号 | 作用     |
| :------- | :------- |
| NOT 或 ! | 逻辑非   |
| AND      | 逻辑与   |
| OR       | 逻辑或   |
| XOR      | 逻辑异或 |

### Ⅳ 位运算

位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。

MySQL支持的位运算符如下：

| 运算符号 | 作用              |
| :------- | :---------------- |
| &        | 按位与（位AND）   |
| \|       | 按位或（位OR）    |
| ^        | 按位异或（位XOR） |
| !        | 按位取反          |
| <<       | 左移              |
| >>       | 右移              |

### Ⅴ 非符号类型运算符

| 运算符              | 名称                   | 作用                               |
| ------------------- | ---------------------- | ---------------------------------- |
| IS （NOT） NULL     | （不）为空运算符       | 判断值、字符串或表达式是否为空     |
| LEAST               | 最小值运算符           | 在多个值中返回最小值               |
| GREATEST            | 最大值运算符           | 在多个值中返回最大值               |
| （NOT） BETWEEN AND | （非）两值之间的运算符 | 判断一个值是否在两个值之间         |
| （NOT）IN           | （不）属于运算符       | 判断一个值是否为列表中的任意一个值 |

### Ⅵ 模糊匹配和正则表达式（LIKE、REGEXP和RLIKE）

| 运算符        | 名称             | 作用                               |
| ------------- | ---------------- | ---------------------------------- |
| LIKE          | 模糊匹配运算符   | 判断一个值是否符合模糊匹配规则     |
| REGEXP和RLIKE | 正则表达式运算符 | 判断一个值是否符合正则表达式的规则 |

LIKE：常用通配符：% 、_ 、escape

```
% : 匹配0个或任意多个字符
_ : 匹配任意一个字符
escape ： 转义字符，可匹配%和_。如SELECT * FROM table_name WHERE column_name LIKE '/%/_%_' ESCAPE'/'
```

RLIKE和REGEXP :常用通配符：. 、* 、 [] 、 ^ 、 $ 、{n}

```
^ : 匹配开头，如'^s'匹配以s或者S开头的字符串。
$ : 匹配结尾，如's$'匹配以s结尾的字符串。
. : 匹配任意单个字符。
* : 匹配0个或多个前一个字符，如'a*'。
+ : 匹配1个或多个前一个字符。
[ ] : 匹配在方括号内的任何字符。例如，'[abc]'匹配'a'或'b'或'c'。为了命名字符的范围，使用一 个'-'。'[a-z]'匹配任何字母，而'[0-9]'匹配任何数字。
[^ ] : 匹配不在方括号内的任何字符。如'[^abc]'。匹配不是'a'或'b'或'c'的字符。
{n} : 匹配前一个字符反复n次。
{n,m} : 匹配前一个字符最少n次，最多m次。
```

注意：
1. 在MySQL中，like、rlike和regexp都不区分大小写，如果需要区分，可以在WHERE后添加关键字段binary。
2. like是完全匹配。rlike和regexp是不完全匹配，只要不同时匹配^和 $， 其他的包含即可。如 ^ba可以匹配baaa和baab，a也可以匹配baaa和baab，但是^bab$不能匹配baab。

## 5、排序与分页

### Ⅰ 排序数据（ORDER BY）

- 使用 ORDER BY 子句排序
  - ASC(ascend)：升序
  - DESC(descend)：降序
- **ORDER BY 子句在SELECT语句的结尾**。
- ORDER BY 可排序多列数据，但是只有排序的第一列有相同的列值时，才会对第二列进行排序。
- 可以使用不在SELECT关键字后获取的列中的字段进行排序。

### Ⅱ 分页（LIMIT）

- 分页原理：所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。
- 语法和案例：

```mysql
#格式
LIMIT [位置偏移量,] 行数
#前10条记录
SELECT * FROM 表名 LIMIT 0,10;
或
SELECT * FROM 表名 LIMIT 10;

#前11至20调记录
SELECT * FROM 表名 LIMIT 10,20;

#第21至30条记录： 
SELECT * FROM 表名 LIMIT 20,10;

#分页显示指定页公式：LIMIT (当前页数-1)*每页条数，每页条数
```

- 注意：**LIMIT 子句必须放在整个SELECT语句的最后**
- **使用LIMIT的好处**：约束返回结果的数量可以 减少数据表的网络传输量 ，也可以 提升查询效率 。如果我们知道返回结果只有1 条，就可以使用 LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。
- 扩展：

在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。

```sql
#SQL Server 和 Access，需要使用 TOP 关键字
SELECT TOP 5 id, name FROM students ORDER BY id DESC

#DB2，使用 FETCH FIRST 5 ROWS ONLY 这样的关键字：
SELECT id, name FROM students ORDER BY id DESC FETCH FIRST 5 ROWS ONLY

#Oracle，需要基于 ROWNUM（隐藏字段）
SELECT ROWNUM, id, name FROM students WHERE ROWNUM < 5 ORDER BY id DESC;
```

## 6、多表查询

### Ⅰ 使用背景和笛卡尔积

- 多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。
- **前提条件**：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是**有关联字段**，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。
- SQL92中，**笛卡尔积**也称为 交叉连接 ，英文是 **CROSS JOIN** 。在 SQL99 中也是使用 CROSS JOIN表示交叉连接（内连接）。它的作用就是可以把任意表进行连接，即使这两张表不相关。
- **笛卡尔积的错误**：直接或错误地连接多个表查询时，查询结果的行数，等于连接的每个子表的行数之积。
- **笛卡尔积的错误会在下面条件下产生**：
  - 省略多个表的连接条件（或关联条件）。
  - 连接条件（或关联条件）无效。
  - 所有表中的所有行互相连接。

### Ⅱ 分类（多表连接类型）

1. 等值连接和非等值连接：
   - 等值连接（=）：当一个表的非主键字段是另一个表的唯一、非空字段时。**连接n个表至少需要n-1个连接条件**，否则出现笛卡尔积错误。
   - 非等值连接：使用BETWEEN AND等非 = 条件语句去匹配另一个表的唯一列或列组。
2. 自连接和非自连接：
   - 自连接：当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。如商品分类表中有字段 id(主键id)和parent_id(父级id),一种商品就指向自己唯一的父级分类。
3. 内连接和外连接：
   - 内连接（**交集**）：如合并两个表时，第一个表的列希望对应的另一个表唯一列不存在时, **结果集中不包含一个表与另一个表不匹配的行**。关键字 **INNER(可省略) JOIN** ：获取两个表中字段匹配关系的记录。
   - 外连接（**并集，但需要分左右**）：两个表在连接过程中除了返回满足连接条件的行以外**还返回左（或右）表中不满足条件的**行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。
   - 左连接(LEFT JOIN)：获取左表所有记录，即使右表没有对应匹配的记录。JOIN关键字左边的表也称为**主表**，右边称为**从表**。
   - 右连接(RIGHT JOIN)：与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。JOIN关键字右边的表也称为主表，左边称为从表。
   - **SQL92** 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。如 tablename(+)。但是MySQL不支持，Oracle是支持的。

### Ⅲ SQL99语法实现多表查询

- 使用JOIN...ON子句创建连接的语法结构：

```mysql
SELECT table1.column, table2.column,table3.column 
FROM table1 
	JOIN table2 ON table1 和 table2 的连接条件
		JOIN table3 ON table2 和 table3 的连接条件
```

SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。

- 语法说明：
  - **可以使用** **ON** **子句指定额外的连接条件**。
  - 这个连接条件是与其它条件分开的。
  - **ON 子句使语句具有更高的易读性**。
  - 关键字 **JOIN、INNER JOIN、CROSS JOIN 的含义是一样的**，都表示内连接。
- 满外连接：
  - 左外连接=左表全部记录+相关联结果。
  - 右外连接=右表全部记录+相关联结果。
  - 全外连接=左表全部记录+右表全部记录+相关联结果=左外连接+右外连接-相关联结果（即去重复）。
  - SQL99是支持满外连接的。使用(Oracle支持)FULL JOIN 或 FULL OUTER JOIN来实现。但是，**MySQL不支持FULL JOIN**。但可以使用**UNION**关键字来合并左连接查询和右连接查询结果（需要注意的是查询列需一一对应）。


### Ⅳ UNION的使用

**合并查询结果** MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会默认删除重复的数据。**两个表对应的列数和数据类型必须相同，并且相互对应**。语法各个SELECT语句之间使用UNION或UNION ALL关键字分隔。

```mysql
SELECT column,... FROM table1 [WHERE conditions]
UNION [ALL] #ALL会返回包括重复数据的所有结果集
SELECT column,... FROM table2 [WHERE conditions]
```

使用情况：

- 可以把一张表抽象成多张表去做交、并集。例如对同一个表中同一条记录按不同字段输出多条。
- **满外连接**，当需要把多张具有相似字段的表中的记录提取出来，两张表不需要字段上必然的联系。例如把学生表中大四学生，和老师表中的小于30岁的筛出来去打疫苗，SELECT的列就取id和name。

### Ⅴ 7种SQL JOINS的实现

![image-20220224154656023](https://cdn.jsdelivr.net/gh/mrsenmu/JavaLearningNotes/images/mysql/202202241556855.png)

- 需要注意的是对于正下方的两种情况，MySQl中是不支持满外连接（FULL OUTER JOIN）的。
- 在MySQL中可以通过UNION关键字合并左右连接表查询来实现，ALL决定是否去重。
- 正下方左图

```mysql
#实现查询结果是A∪B 
#用左外的A，union 右外的B 
SELECT 字段列表
FROM A表 LEFT JOIN B表 ON 关联条件 WHERE 等其他子句 
UNION
SELECT 字段列表
FROM A表 RIGHT JOIN B表 ON 关联条件 WHERE 等其他子句;
```

- 正下方右图

```mysql
#实现A∪B - A∩B 或 (A - A∩B) ∪ （B - A∩B） 
#使用左外的 (A - A∩B) union 右外的（B - A∩B） 
SELECT 字段列表
FROM A表 LEFT JOIN B表 ON 关联条件 WHERE 从表关联字段 IS NULL AND 等其他子句 
UNION
SELECT 字段列表
FROM A表 RIGHT JOIN B表 ON 关联条件 WHERE 从表关联字段 IS NULL AND 等其他子句
```

### Ⅵ SQL99语法新特性

(1) **自然连接**

SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 **NATURAL JOIN** 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 **所有相同的字段** ，然后进行 **等值** 连接 。 

在SQL92标准中：

```mysql
SELECT employee_id,last_name,department_name 
FROM employees e JOIN departments d 
ON e.`department_id` = d.`department_id` 
AND e.`manager_id` = d.`manager_id`;
```

在 SQL99 中你可以写成：

```mysql
SELECT employee_id,last_name,department_name 
FROM employees e NATURAL JOIN departments d;
```

(2) **USING连接**

当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 **同名字段** 进行等值连接。但是只能配合JOIN一起使用。在 USING的括号 () 中填入要指定的同名字段。比如

```mysql
SELECT employee_id,last_name,department_name 
FROM employees e JOIN departments d 
USING (department_id);
```

### Ⅷ 总结

表连接的约束条件可以有三种方式：WHERE, ON, USING。

- WHERE：适用于所有关联查询。
- ON ：只能和 JOIN 一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。
- USING：只能和 JOIN 一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等。

**注意**：

我们要 **控制连接表的数量** 。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。

```
【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。

说明：即使双表 join 也要注意表索引、SQL 性能。

来源：阿里巴巴《Java开发手册》
```

## 7、单行函数

### Ⅰ 函数的理解

(1) **什么是函数**

函数在计算机语言的使用中贯穿始终，它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既 **提高了代码效率** ，又 **提高了可维护性** 。在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地 **提高用户对数据库的管理效率** 。

![image-20220224165713701](https://cdn.jsdelivr.net/gh/mrsenmu/JavaLearningNotes/images/mysql/202202241657773.png)

从函数定义的角度出发，将函数分成 **内置函数** 和 **自定义函数** 。在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的。

(2) **不同DBMS函数的差异**

我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即DBMS。**DBMS** **之间的差异性很大，远大于同一个语言不同版本之间的差异。**实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为concat()。**大部分 DBMS 会有自己特定的函数**，这就意味着**采用** **SQL** **函数的代码可移植性是很差的**，因此在使用函数的时候需要特别注意。

(3) **MySQL的内置函数及分类**

MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。

MySQL提供的内置函数从 **实现的功能角度** 可以分为**数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等**。这里，我将这些丰富的内置函数再分为两类： **单行函数 、 聚合函数（或分组函数、多行函数）** 。

(4)**两种SQL函数**

**单行函数**:

- 操作数据对象
- 接受参数返回一个结果
- **只对一行进行变换**
- **每行返回一个结果**
- 可以嵌套
- 参数可以是一列或一个值

**聚合函数**：



### Ⅱ 数值函数

(1) 基本函数

| **函数**            | **用法**                                                     |
| ------------------- | ------------------------------------------------------------ |
| ABS(x)              | 返回x的绝对值                                                |
| SIGN(X)             | 返回X的符号。正数返回1，负数返回-1，0返回0                   |
| PI()                | 返回圆周率的值                                               |
| CEIL(x)，CEILING(x) | 返回大于或等于某个值的最小整数                               |
| FLOOR(x)            | 返回小于或等于某个值的最大整数                               |
| LEAST(e1,e2,e3…)    | 返回列表中的最小值                                           |
| GREATEST(e1,e2,e3…) | 返回列表中的最大值                                           |
| MOD(x,y)            | 返回X除以Y后的余数                                           |
| RAND()              | 返回0~1的随机值                                              |
| RAND(x)             | 返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数 |
| ROUND(x)            | 返回一个对x的值进行四舍五入后的整数                          |
| ROUND(x,y)          | 返回一个对x的值进行四舍五入后的值，并保留到小数点后面Y位（如 ROUND(1.68, 1) = 1.7） |
| TRUNCATE(x,y)       | 返回数字x截断为y位小数的结果（如 ROUND(1.68, 1) = 1.6）      |
| SQRT(x)             | 返回x的平方根。当X的值为负数时，返回NULL                     |

(2) **角度与弧度互换函数**

| **函数**   | **用法**                              |
| ---------- | ------------------------------------- |
| RADIANS(x) | 将角度转化为弧度，其中，参数x为角度值 |
| DEGREES(x) | 将弧度转化为角度，其中，参数x为弧度值 |

(3) **三角函数**

| **函数**   | **用法**                                                     |
| ---------- | ------------------------------------------------------------ |
| SIN(x)     | 返回x的正弦值，其中，参数x为弧度值                           |
| ASIN(x)    | 返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL |
| COS(x)     | 返回x的余弦值，其中，参数x为弧度值                           |
| ACOS(x)    | 返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL |
| TAN(x)     | 返回x的正切值，其中，参数x为弧度值                           |
| ATAN(x)    | 返回x的反正切值，即返回正切值为x的值                         |
| ATAN2(m,n) | 返回两个参数的反正切值                                       |
| COT(x)     | 返回x的余切值，其中，X为弧度值                               |

(4) **指数与对数**

| **函数**             | **用法**                                             |
| -------------------- | ---------------------------------------------------- |
| POW(x,y)，POWER(X,Y) | 返回x的y次方                                         |
| EXP(X)               | 返回e的X次方，其中e是一个常数，2.718281828459045     |
| LN(X)，LOG(X)        | 返回以e为底的X的对数，当X <= 0 时，返回的结果为NULL  |
| LOG10(X)             | 返回以10为底的X的对数，当X <= 0 时，返回的结果为NULL |
| LOG2(X)              | 返回以2为底的X的对数，当X <= 0 时，返回NULL          |

(5) **进制转换**

| **函数**      | **用法**                 |
| ------------- | ------------------------ |
| BIN(x)        | 返回x的二进制编码        |
| HEX(x)        | 返回x的十六进制编码      |
| OCT(x)        | 返回x的八进制编码        |
| CONV(x,f1,f2) | 返回f1进制数变成f2进制数 |

### Ⅲ 字符函数

**注意：MySQL中，字符串的位置是从1开始的。**

| **函数**                           | **用法**                                                     |
| ---------------------------------- | ------------------------------------------------------------ |
| ASCII(S)                           | 返回字符串S中的第一个字符的ASCII码值                         |
| CHAR_LENGTH(s)                     | 返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同           |
| LENGTH(s)                          | 返回字符串s的字节数，和字符集有关                            |
| CONCAT(s1,s2,......,sn)            | 连接s1,s2,......,sn为一个字符串                              |
| CONCAT_WS(x,  s1,s2,......,sn)     | 同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x           |
| INSERT(str, idx,  len, replacestr) | 将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr |
| REPLACE(str, a, b)                 | 用字符串b替换字符串str中所有出现的字符串a                    |
| UPPER(s) 或 UCASE(s)               | 将字符串s的所有字母转成大写字母                              |
| LOWER(s) 或LCASE(s)                | 将字符串s的所有字母转成小写字母                              |
| LEFT(str,n)                        | 返回字符串str左边的n个字符                                   |
| RIGHT(str,n)                       | 返回字符串str右边的n个字符                                   |
| LPAD(str, len, pad)                | 用字符串pad对str左边进行填充，直到str的长度为len个字符       |
| RPAD(str ,len, pad)                | 用字符串pad对str右边进行填充，直到str的长度为len个字符       |
| LTRIM(s)                           | 去掉字符串s左侧的空格                                        |
| RTRIM(s)                           | 去掉字符串s右侧的空格                                        |
| TRIM(s)                            | 去掉字符串s开始与结尾的空格                                  |
| TRIM(s1 FROM s)                    | 去掉字符串s开始与结尾的s1                                    |
| TRIM(LEADING s1  FROM s)           | 去掉字符串s开始处的s1                                        |
| TRIM(TRAILING s1  FROM s)          | 去掉字符串s结尾处的s1                                        |
| REPEAT(str, n)                     | 返回str重复n次的结果                                         |
| SPACE(n)                           | 返回n个空格                                                  |
| STRCMP(s1,s2)                      | 比较字符串s1,s2的ASCII码值的大小                             |
| SUBSTR(s,index,len)                | 返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、  MID(s,n,len)相同 |
| LOCATE(substr,str)                 | 返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr  IN str)、INSTR(str,substr)相同。未找到，返回0 |
| ELT(m,s1,s2,…,sn)                  | 返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn |
| FIELD(s,s1,s2,…,sn)                | 返回字符串s在字符串列表中第一次出现的位置                    |
| FIND_IN_SET(s1,s2)                 | 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串 |
| REVERSE(s)                         | 返回s反转后的字符串                                          |
| NULLIF(value1,value2)              | 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回  value1 |

### Ⅳ 日期和时间函数

(1) **获取时间、日期**

| **函数**                                                     | **用法**                                    |
| ------------------------------------------------------------ | ------------------------------------------- |
| **CURDATE()** ，CURRENT_DATE()                               | 返回当前日期，只包含年、月、日(yyyy-MM-dd)  |
| **CURTIME()** ， CURRENT_TIME()                              | 返回当前时间，只包含时、分、秒(HH:mm:ss)    |
| **NOW()** / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() /  LOCALTIMESTAMP() | 返回当前系统日期和时间(yyyy-MM-dd HH:mm:ss) |
| UTC_DATE()                                                   | 返回UTC（世界标准时间）日期                 |
| UTC_TIME()                                                   | 返回UTC（世界标准时间）时间                 |

(2) **日期与时间戳的转换**

| **函数**                 | **用法**                                                     |
| ------------------------ | ------------------------------------------------------------ |
| UNIX_TIMESTAMP()         | 以UNIX时间戳的形式返回当前时间。SELECT  UNIX_TIMESTAMP() ->1634348884 |
| UNIX_TIMESTAMP(date)     | 将时间date以UNIX时间戳的形式返回。                           |
| FROM_UNIXTIME(timestamp) | 将UNIX时间戳的时间转换为普通格式的时间                       |

(3) **获取月份、星期数、天数等函数**

| **函数**                                   | **用法**                                          |
| ------------------------------------------ | ------------------------------------------------- |
| YEAR(date) /  MONTH(date) / DAY(date)      | 返回具体的日期值                                  |
| HOUR(time) /  MINUTE(time) /  SECOND(time) | 返回具体的时间值                                  |
| MONTHNAME(date)                            | 返回月份：January，...                            |
| DAYNAME(date)                              | 返回星期几：MONDAY，TUESDAY.....SUNDAY            |
| WEEKDAY(date)                              | 返回周几，注意，周1是0，周2是1, ... 周日是6       |
| QUARTER(date)                              | 返回日期对应的季度，范围为1～4                    |
| WEEK(date) ，  WEEKOFYEAR(date)            | 返回一年中的第几周                                |
| DAYOFYEAR(date)                            | 返回日期是一年中的第几天                          |
| DAYOFMONTH(date)                           | 返回日期位于所在月份的第几天                      |
| DAYOFWEEK(date)                            | 返回周几，注意：周日是1，周一是2，。。。周六是  7 |

(4) **日期的操作函数**

| **函数**                 | **用法**                                   |
| ------------------------ | ------------------------------------------ |
| EXTRACT(type FROM  date) | 返回指定日期中特定的部分，type指定返回的值 |

![image-20220225150241284](https://cdn.jsdelivr.net/gh/mrsenmu/JavaLearningNotes/images/mysql/202202251502178.png)

(5) **时间和秒钟转换的函数**

| **函数**             | **用法**                                                     |
| -------------------- | ------------------------------------------------------------ |
| TIME_TO_SEC(time)    | 将 time 转化为秒并返回结果值。转化的公式为：**小时*3600+分钟 *60+秒** |
| SEC_TO_TIME(seconds) | 将 seconds 描述转化为包含小时、分钟和秒的时间                |

(6) **计算日期和时间的函数**

**参数类型变更类**：

| **函数**                                                     | **用法**                                       |
| ------------------------------------------------------------ | ---------------------------------------------- |
| DATE_ADD(datetime,  INTERVAL expr type)，  ADDDATE(date,INTERVAL  expr type) | 返回与给定日期时间相差INTERVAL时间段的日期时间 |
| DATE_SUB(date,INTERVAL  expr type)，  SUBDATE(date,INTERVAL  expr type) | 返回与date相差INTERVAL时间间隔的日期           |

上述函数中type的取值：

![image-20220225155005974](https://cdn.jsdelivr.net/gh/mrsenmu/JavaLearningNotes/images/mysql/202202251550462.png)

**函数名变更类**：

| **函数**                     | **用法**                                                     |
| ---------------------------- | ------------------------------------------------------------ |
| ADDTIME(time1,time2)         | 返回time1加上time2的时间。当time2为一个数字时，代表的是秒，可以为负数 |
| SUBTIME(time1,time2)         | 返回time1减去time2后的时间。当time2为一个数字时，代表的是秒，可以为负数 |
| DATEDIFF(date1,date2)        | 返回date1 - date2的日期间隔天数                              |
| TIMEDIFF(time1,  time2)      | 返回time1 - time2的时间间隔                                  |
| FROM_DAYS(N)                 | 返回从0000年1月1日起，N天以后的日期                          |
| TO_DAYS(date)                | 返回日期date距离0000年1月1日的天数                           |
| LAST_DAY(date)               | 返回date所在月份的  后一天的日期                             |
| MAKEDATE(year,n)             | 针对给定年份与所在年份中的天数返回一个日期                   |
| MAKETIME(hour,minute,second) | 将给定的小时、分钟和秒组合成时间并返回                       |
| PERIOD_ADD(time,n)           | 返回time加上n后的时间                                        |

(7) **日期的格式化与解析**

| **函数**                          | **用法**                                   |
| --------------------------------- | ------------------------------------------ |
| DATE_FORMAT(date,fmt)             | 按照字符串fmt格式化日期date值              |
| TIME_FORMAT(time,fmt)             | 按照字符串fmt格式化时间time值              |
| GET_FORMAT(date_type,format_type) | 返回日期字符串的显示格式                   |
| STR_TO_DATE(str,  fmt)            | 按照字符串fmt对str进行解析，解析为一个日期 |

上述非GET_FORMAT函数中fmt参数常用的格式符：

| **格式符** | **说明**                                                     | **格式符** | **说明**                                                     |
| ---------- | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ |
| %Y         | 4位数字表示年份                                              | %y         | 表示两位数字表示年份                                         |
| %M         | 月名表示月份（January,....）                                 | %m         | 两位数字表示月份  （01,02,03。。。）                         |
| %b         | 缩写的月名（Jan.，Feb.，....）                               | %c         | 数字表示月份（1,2,3,...）                                    |
| %D         | 英文后缀表示月中的天数  （1st,2nd,3rd,...）                  | %d         | 两位数字表示月中的天数(01,02...)                             |
| %e         | 数字形式表示月中的天数  （1,2,3,4,5.....）                   |            |                                                              |
| %H         | 两位数字表示小数，24小时制  （01,02..）                      | %h 和%I    | 两位数字表示小时，12小时制  （01,02..）                      |
| %k         | 数字形式的小时，24小时制(1,2,3)                              | %l         | 数字形式表示小时，12小时制  （1,2,3,4....）                  |
| %i         | 两位数字表示分钟（00,01,02）                                 | %S 和%s    | 两位数字表示秒(00,01,02...)                                  |
| %W         | 一周中的星期名称（Sunday...）                                | %a         | 一周中的星期缩写（Sun.，  Mon.,Tues.，..）                   |
| %w         | 以数字表示周中的天数  (0=Sunday,1=Monday....)                |            |                                                              |
| %j         | 以3位数字表示年中的天数(001,002...)                          |            |                                                              |
| %u         | 以数字表示年中的第几周，  （1,2,3。。）其中Monday为周中第一天 | %U         | 以数字表示年中的第几周，  （1,2,3。。）其中Sunday为周中第一天 |
| %T         | 24小时制                                                     | %r         | 12小时制                                                     |
| %p         | AM或PM                                                       | %%         | 表示%                                                        |

GET_FORMAT函数中date_type和format_type参数取值如下：

![image-20220225160135988](https://cdn.jsdelivr.net/gh/mrsenmu/JavaLearningNotes/images/mysql/202202251601355.png)

### Ⅴ 流程控制函数

流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。

| **函数**                                                     | **用法**                                        |
| ------------------------------------------------------------ | ----------------------------------------------- |
| IF(value,value1,value2)                                      | 如果value的值为TRUE，返回value1，否则返回value2 |
| IFNULL(value1,  value2)                                      | 如果value1不为NULL，返回value1，否则返回value2  |
| CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2  .... [ELSE resultn]  END | 相当于Java的if...else  if...else...             |
| CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END | 相当于Java的switch...case...                    |

### Ⅵ 加密与解密函数

加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。

| **函数**                    | **用法**                                                     |
| --------------------------- | ------------------------------------------------------------ |
| PASSWORD(str)               | 返回字符串str的加密版本，41位长的字符串。加密结果不可逆，常用于用户的密码加密 |
| MD5(str)                    | 返回字符串str的md5加密后的值，也是一种加密方式。若参数为  NULL，则会返回NULL |
| SHA(str)                    | 从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。SHA加密算法比MD5更加安全。 |
| ENCODE(value,password_seed) | 返回使用password_seed作为加密密码 加密value                  |
| DECODE(value,password_seed) | 返回使用password_seed作为加密密码 解密value                  |

### Ⅶ MySQL信息函数

MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。

| **函数**                                                | **用法**                                                   |
| ------------------------------------------------------- | ---------------------------------------------------------- |
| VERSION()                                               | 返回当前MySQL的版本号                                      |
| CONNECTION_ID()                                         | 返回当前MySQL服务器的连接数                                |
| DATABASE()，SCHEMA()                                    | 返回MySQL命令行当前所在的数据库                            |
| USER()，CURRENT_USER()、SYSTEM_USER()，  SESSION_USER() | 返回当前连接MySQL的用户名，返回结果格式为  “主机名@用户名” |
| CHARSET(value)                                          | 返回字符串value自变量的字符集                              |
| COLLATION(value)                                        | 返回字符串value的比较规则                                  |

### Ⅷ 其他函数

MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视的。

| **函数**                        | **用法**                                                     |
| ------------------------------- | ------------------------------------------------------------ |
| FORMAT(value,n)                 | 返回对数字value进行格式化后的结果数据。n表示四舍五入后保留到小数点后n位 |
| CONV(value,from,to)             | 将value的值进行不同进制之间的转换                            |
| INET_ATON(ipvalue)              | 将以点分隔的IP地址转化为一个数字                             |
| INET_NTOA(value)                | 将数字形式的IP地址转化为以点分隔的IP地址                     |
| BENCHMARK(n,expr)               | 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间 |
| CONVERT(value USING  char_code) | 将value所使用的字符编码修改为char_code                       |

## 8、聚合函数

### Ⅰ 介绍

聚合函数作用于一组数据，并对一组数据返回一个值。

![image-20220225175323359](https://cdn.jsdelivr.net/gh/mrsenmu/JavaLearningNotes/images/mysql/202202251753808.png)

常用的聚合函数类型有：

- AVG(column)
- SUM(column)
- MAX(column)
- MIN(column)
- COUNT()

**问题：用count(\*)，count(1)，count(列名)谁好呢?**

对于**MyISAM引擎**的表是没有区别的。这种引擎内部有一计数器在维护着行数。

**Innodb引擎**的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。

**问题：能不能使用count(列名)替换count(\*)?**

不要使用 count(列名)来替代 count(\*) ， count(\*) 是 SQL92 定义的标准统计行数的语法，跟数

据库无关，跟 NULL 和非 NULL 无关。

说明：**count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行**。

### Ⅱ  基本使用

- 使用GROUP BY子句将表中的数据分组。
- 使用**WITH ROLLUP**可对分组记录求和，存储在一条新的记录中。

### Ⅲ HAVING

**过滤分组：HAVING子句，置于GROUP BY之后**

1. 行已经被分组。
2. 使用了聚合函数。
3. 满足HAVING子句中条件的分组将被显示。
4. HAVING不能单独使用，必须要跟GROUP BY一起使用。

**错误的使用聚合函数：不能在WHERE子句中使用聚合函数。**

**WHERE和HAVING的区别：**

1. HAVING必须和GROUP BY配合使用，以分组计算的函数或分组字段作为筛选条件，而WHERE可直接将表中字段作为筛选条件，并且由于WHERE在GROUP BY之前，所以不能对分组结果进行筛选。
2. **如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而 HAVING 是先连接后筛选。**因此，在关联查询中，WHERE比HAVING更高效。因为先筛选后数据量更小，占用资源更少。

| WHERE  | 先筛选数据再关联     | 不能使用分组中的计算函数进行筛选   |
| ------ | ------------------------ | -------------------------------------- |
| HAVING | 可以使用分组中的计算函数 | 在最后的结果集中进行筛选，执行效率较低 |

开发中配合使用，HAVING只用于分组统计函数。

SELECT查询时的两个顺序：

1.  **关键字的顺序是不能颠倒的：**

```sql
SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...
```

2. **SELECT** **语句的执行顺序**（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：

```sql
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段 -> DISTINCT -> ORDER BY -> LIMIT
如下：
SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5
FROM player JOIN team ON player.team_id = team.team_id # 顺序 1
WHERE height > 1.80 # 顺序 2
GROUP BY player.team_id # 顺序 3
HAVING num > 2 # 顺序 4
ORDER BY num DESC # 顺序 6
LIMIT 2 # 顺序 7
```

在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。

## **9、子查询**

描述：嵌套在另一个查询语句内部的查询，用于从另一个查询的结果集中查询。

### Ⅰ 基本使用

- 子查询（内查询）在主查询之前一次执行完成。
- 子查询的结果被主查询（外查询）使用。
- **注意：**
  - 子查询要包含在括号内。
  - 将子查询放在比较条件的右侧。
  - 单行操作符对应单行子查询，多行操作符对应多行子查询。
- 分类：
  - 按**子查询的结果返回一条还是多条记录**，将子查询分为**单行子查询、多行子查询**。
  - 按**子查询是否被执行多次**，将子查询划分为**相关(或关联)子查询和不相关(或非关联)子查询**。

### Ⅱ 单行子查询

1. 单行比较操作符：=、>、>=、<、<=、<>。
2. 案例：如求员工表中工资 > 张三的员工，此时子查询获取张三的工资。

### Ⅲ 多行子查询

1. 多行比较操作符：

| 操作符   | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| (NOT) IN | 等于列表中的任意一个                                         |
| ANY      | 需要和单行比较操作符一起使用**(在其之后)**，和子查询返回的**某一个**值比较 |
| ALL      | 需要和单行比较操作符一起使用，和子查询返回的**所有**值比较   |
| SOME     | 实际上是ANY的别名，作用相同，一般常使用ANY                   |

### Ⅳ 关联子查询

​	如果子查询的执行依赖于外部查询，通常情况下都是因为**子查询中的表用到了外部的表**，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。

**EXISTS与NOT EXISTS关键字**

- 通常与关联子查询一起使用，用于检查子查询中是否存在满足条件的行。
- 如果在子查询中不存在满足条件的行：
  - 条件返回FALSE
  - 继续在子查询中查找
- 如果在子查询中存在满足条件的行
  - 不在子查询中继续查找
  - 条件返回TRUE

对于同一表的操作，使用自连接替代子查询，能得到快得多的效率。

# **三、SQL之DDL、DML、DCL的使用**

## **1、创建和管理库**

1. 数据类型

| **类型**         | **类型举例**                                                 |
| ---------------- | ------------------------------------------------------------ |
| 整数类型         | TINYINT、SMALLINT、MEDIUMINT、**INT(****或****INTEGER)**、BIGINT |
| 浮点类型         | FLOAT、DOUBLE                                                |
| 定点数类型       | **DECIMAL**                                                  |
| 位类型           | BIT                                                          |
| 日期时间类型     | YEAR、TIME、**DATE**、DATETIME、TIMESTAMP                    |
| 文本字符串类型   | CHAR、**VARCHAR**、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT      |
| 枚举类型         | ENUM                                                         |
| 集合类型         | SET                                                          |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB      |
| JSON类型         | JSON对象、JSON数组                                           |
| 空间数据类型     | 单值：GEOMETRY、POINT、LINESTRING、POLYGON；集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION |

常用的几类

| **数据类型**  | **描述**                                                     |
| ------------- | ------------------------------------------------------------ |
| INT           | 从-2^31到2^31-1的整型数据。存储大小为 4个字节                |
| CHAR(size)    | 定长字符数据。若未指定，默认为1个字符，最大长度255           |
| VARCHAR(size) | 可变长字符数据，根据字符串实际长度保存，**必须指定长度**     |
| FLOAT(M,D)    | 单精度，占用4个字节，M=整数位+小数位，D=小数位。 D<=M<=255,0<=D<=30，默认M+D<=6 |
| DOUBLE(M,D)   | 双精度，占用8个字节，D<=M<=255,0<=D<=30，默认M+D<=15         |
| DECIMAL(M,D)  | 高精度小数，占用M+2个字节，D<=M<=65，0<=D<=30，最大取值范围与DOUBLE相同。 |
| DATE          | 日期型数据，格式'YYYY-MM-DD'                                 |
| BLOB          | 二进制形式的长文本数据，最大可达4G                           |
| TEXT          | 长文本数据，最大可达4G                                       |



### Ⅰ 创建

```sql
# 方式1：创建数据库
CREATE DATABASE 数据库名;
# 方式2：创建数据库并指定字符集
CREATE DATABASE 数据库名 CHARACTER SET 字符集;
# 方式3：判断数据库是否已经存在，不存在则创建数据库（ 推荐 ）
CREATE DATABASE IF NOT EXISTS 数据库名;
```

注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。

### Ⅱ 使用

```sql
#查看当前所有的数据库
SHOW DATABASES; #有一个S，代表多个数据库
#查看当前正在使用的数据库
SELECT DATABASE(); #使用的一个 mysql 中的全局函数
#查看指定库下所有的表
SHOW TABLES FROM 数据库名;
#查看数据库的创建信息
SHOW CREATE DATABASE 数据库名; 
#或者：
SHOW CREATE DATABASE 数据库名\G
#使用/切换数据库
USE 数据库名;
#修改数据库 更新数据库字符集
ALTER DATABASE 数据库名 CHARACTER SET 字符集; #比如：gbk、utf8等
#删除数据库
DROP DATABASE IF EXISTS 数据库名;
```

注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数

据库名.”。 

## **2、创建和管理表**

### Ⅰ 创建表

```sql
#方式1
CREATE TABLE [IF NOT EXISTS] 表名(
    字段1, 数据类型 [约束条件] [默认值],
    字段2, 数据类型 [约束条件] [默认值],
    字段3, 数据类型 [约束条件] [默认值],
    ……[表约束条件] 
);
#方式2
结合查询语句
#查看数据表结构（包括存储引擎和字符编码）
SHOW CREATE TABLE 表名\G
```

### Ⅱ 修改表

```sql
#追加一个列
ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】;
#修改一个列，可修改列的数据类型，长度、默认值和位置，对于默认值的修改只影响今后对表的修改
ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名 2】;
#重命名一个列
ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型;
#删除一个列
ALTER TABLE 表名 DROP 【COLUMN】字段名

#重命名表
#方式1
RENAME TABLE emp TO myemp;
#方式2
ALTER table dept RENAME [TO] detail_dept; -- [TO]可以省略
```

### Ⅲ 删除表

- 在MySQL中，当一张数据表 没有与其他任何数据表形成关联关系 时，可以将当前数据表直接删除
- 数据和结构都被删除
- 所有正在运行的相关事务被提交
- 所有相关索引被删除
- **DROP TABLE 语句不能回滚**
- 语法格式：

```sql
DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];
```

### Ⅳ 清空表

- TRUNCATE TABLE语句：
  - 删除表中所有的数据
  - 释放表的存储空间

```sql
TRUNCATE TABLE table_name
```

- **TRUNCATE语句不能回滚，而使用DELETE语句删除数据，可以回滚**
- 

## **3、数据处理之增删改查**



## **4、MySQL数据类型**



## **5、约束**



# **四、其他数据库对象**

## **1、视图**



## **2、存储过程**



## **3、变量、流程图与游标**



## **4、触发器**



# **五、MySQL8.0其他新特性**

## **1、窗口函数**



## **2、公用表表达式**