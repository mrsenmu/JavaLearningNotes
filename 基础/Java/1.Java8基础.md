

# 一、Java基本语法

## 1、变量

### Ⅰ 命名规范

| 包名         | 多单词组成时所有字母都小写：xxxyyyzzz                        |
| ------------ | ------------------------------------------------------------ |
| 类名         | 接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz        |
| 变量、方法名 | 多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz |
| 常量名       | 所有字母都大写。多单词时每个单词用下划线连接：XXX YYY ZZZ    |

### Ⅱ 变量初始化

- 变量为**局部变量**时必须先声明，再**初始化值**后使用，否则报错。
- 当变量为类中**成员变量**，实例化对象时会被赋予默认值。
- **数组**对象实例化后，其中**元素**也会被赋予对应类型的默认值。
- **默认值**为：整型为0，浮点型为0.0(f/d)，布尔型为false，字符型为 '/u0000' (空字符，数值为0)，引用类型为NULL。

### **Ⅲ 数据类型**

![be7daa20-1240-464b-b630-c17e224d12f4](https://cdn.jsdelivr.net/gh/mrsenmu/JavaLearningNotes/images/java/202309261630605.jpg)

| 类型名称     | 关键字  | 占用内存 | 取值范围                                   |
| ------------ | ------- | -------- | ------------------------------------------ |
| 字节型       | byte    | 1 字节   | -128~127                                   |
| 短整型       | short   | 2 字节   | -32768~32767                               |
| 整型         | int     | 4 字节   | -2147483648~2147483647                     |
| 长整型       | long    | 8 字节   | -9223372036854775808L~9223372036854775807L |
| 单精度浮点型 | float   | 4 字节   | +/-3.4E+38F（6~7 个有效位）                |
| 双精度浮点型 | double  | 8 字节   | +/-1.8E+308 (15 个有效位）                 |
| 字符型       | char    | 2 字节   | ISO 单一字符集                             |
| 布尔型       | boolean | 1 字节   | true 或 false                              |

- 整型：byte、short、int、long。
- 浮点型：java中小数的默认类型位**double**，要定义float型时需定义时末尾加 **f 或 F，**否则 （如float a = 1.1）会报 **不兼容类型错误：**从double转float可能会有损失。
- 字符型（char）：默认值为0或者说'\u0000'(Unicode表示形式，空字符)。
- 布尔型（boolean）：默认false。
- 7种基本数据类型之间的运算（除布尔型boolean）：
  1. **自动类型提升**：
     - **当容量小的数据类型的变量与容量大的做运算时，会自动转换成容量大的数据类型的变量。**
     - 对于(byte、 char、 short) --> int -- > long --> float -- > double，可用表示数据类型范围大的变量去接收范围小的变量，如 (short b = 1；int c = 2；float a = b + c（a为3.0）)**特别的：**当byte、char、short做运算时，结果都是int型。如short a = 1；a = a +1;编译期就会报错，因为a+1的结果是int型，不能赋给short型，需要强转(short)(a+1)，或者**可用++或+=**。
  2. **强制类型转换 ：**
     - 需要使用强转符（）：如float a = 12.9f；int b = (int)a; (截断操作，a的值为12，精度损失)
     - 可能导致精度损失。对于整型，若强转前值没有超范围，不会精度损失。

- 常量默认类型：整数常量默认类型为int，浮点型常量默认为double。
- String类型变量：string可以与8种基本类型做运算，且只能是**连接运算（+）**，结果为string。

## 2、运算

### **Ⅰ 运算符**

算术运算符、位运算符、关系运算符、逻辑运算符、赋值运算符、三元运算符。

### **Ⅱ 算术运算：**

- 算术运算符：+(正) 、-(符)、+、-、*、\、%、++、--、+(连接)。

- **自增++、自减--，不会改变本身数据类型。**

### **Ⅲ 赋值运算**

- 符号：
  - =当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制
    类型转换原则进行处理。
  - 支持连续赋值。
- 扩展赋值运算符：+=，-=，*=，/=，%=。
- **扩展赋值运算符不改变变量本身数据类型。**

### **Ⅳ 关系运算**

表格中的实例整数变量A的值为10，变量B的值为20：

| 运算符 | 描述                                                         | 例子             |
| ------ | ------------------------------------------------------------ | ---------------- |
| ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。         | （A == B）为假。 |
| !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。     | （A != B) 为真。 |
| >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。   | （A> B）为假。   |
| <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。   | （A <B）为真。   |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |

### Ⅴ **逻辑运算**

| &（逻辑与）  | \|（逻辑或）   | ! （逻辑非）  |
| ------------ | -------------- | ------------- |
| &&（短路与） | \|\|（短路或） | ^（逻辑异或） |

逻辑(与\或)和短路(与\或)的区别是：**逻辑**的符号两边都会计算再判断；而**短路**的是先左后右，满足条件时可提前跳转。

### **Ⅵ 位运算**

1. 下表列出了位运算符的基本运算，假设整数变量 A 的值为 60(0011 1100) 和变量 B 的值为 13(1101)：

| 位运算符 | 描述                                                         | 案例                           |
| -------- | ------------------------------------------------------------ | ------------------------------ |
| ＆       | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
| \|       | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
| ^        | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
| 〜       | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
| <<       | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
| >>       | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
| >>>      | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

2. Java中>>和>>>的区别
   - **>>：**带符号右移。**正数右移高位补0，负数右移高位补1**。比如：4 >> 1，结果是2；-4 >> 1，结果是-2。-2 >> 1，结果是-1。
   - **>>>：**无符号右移。无论是正数还是负数，**高位通通补0**。
   - 对于正数而言，>>和>>>没区别。
   - 对于负数而言，-2 **>>>** 1，结果是2147483647（Integer.MAX_VALUE），-1 **>>>** 1，结果是2147483647（Integer.MAX_VALUE）。所以，要判断两个数符号是否相同时，可以这么干：return ((a >> 31) ^ (b >> 31)) == 0;
3. 对于**取反符~**，流程是：**操作数**

   —> **原码**(正数：符号位0；负数：符号位1) ；

   —> **反码**（正数：不变；负数：原码基础上，符号位不变，其余取反）；

   —> **补码**（正数：不变；负数：反码基础上+1）；

   —>**补码取反**（包括符号位按位取反）；

   —>反码（负数：-1；正数：不变）；

   —>原码（负数：除符号位取反；正数：不变）。

### **Ⅶ 三元运算**

1. 语法：

   - expression1 ? expression2 : expression3。

   - `expression1`可以是计算的，值为` boolean `的任何表达式。如果` expression1 `是` true `，那么将评估` expression2 `。否则，将评估` expression3 `。

   - 表达式1和表达式2为同类型。
2. 三元运算符与if-else的的联系与区别：

     1. 三元运算符可简化if-else语句；
     2. 三元运算符要求必须返回一个结果。
     3. if后的代码块可有多个语句。

## 3、流程控制

### **Ⅰ 三种基本流程结构：**

1. 顺序结构：程序从上到下逐行执行，无跳转和判断。

2. 分支结构：if-else、switch-case两种分支语句。

3. while、do-while、for、foreach（jdk5）。

### **Ⅱ **分支结构

- **包括if-else、switch-case。**
- **switch表达式可有类型（6种）：**jdk5以前，byte、short、char、int；jdk5 加入枚举类型（enum），jdk7时支持String（目前不支持long）。
- **case：常量**（数据类型与switch表达式相同，且不能是表达式）。

# 二、数组（Array）

## **1、 理解**

数组是多个相同类型的数据按一定顺序排列的集合，并使用一个名字命名。

## 2、相关概念

1. 数组名

2. 下标（或索引）

3. 元素

4. 数组的长度

## 3、数组的特点

- 数组是**有序**排列的。
- 数组本身是引用数据类型，其中元素可以是基本类型和引用类型。
- 创建数组对象会在内存中开辟一整块连续的空间，而数组名引用的是这块连续空间的首地址。
- 数组**长度**一旦确定，就不能修改。
- 实例化对象后**元素**会被赋予**默认值**。

## 4、初始化创建

1. 静态初始化：初始化时赋值。int[] a = {1,2,3}。
2. 动态初始化：初始化时确定长度。需要后面动态赋值。int[] a = new Int[3] 。

## 5、Arrays工具类（数组操作）

1. 包含大量数组操作的**静态方法**，直接类名调用。
2. 常用方法(以int型数组为例)：
   - **比较**：boolean equals(int[] a, int[] b);
   - **输出**：String toString(int[] a);
   - **填充指定值（将所有元素替换为指定值）**：void fill(int[] a, int val);
   - **排序**：void sort(int[] a);
   - **二分查找**：int binarySearch(int[] a, int key);

# 三、面向对象

## 1、面向过程与面向对象

### Ⅰ 区别：

- **面向过程**：强调功能行为，以函数为最小单位，考虑怎么做。
- **面向对象**：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。
- **优缺点：**
  - 面向过程：
    - 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
    - 缺点：没有面向对象易维护、易复用、易扩展。
  - 面向对象：
    - 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。
    - 缺点：性能比面向过程低。

### Ⅱ 面向对象三大特性

1. **封装**。是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
2. **继承**。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。
3. **多态性**。它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。

## 2、常用关键字

### Ⅰ package、import

1. package：
   - package的使用是为了实现类的管理，

## 2、封装

### Ⅰ 概述

- **封装性是类和对象概念的主要特性**。在java中主要体现在**权限修饰符**修饰的属性、方法、对象。
- **对象**：是类的一个实例，有状态和行为。
- **类**：一个模板，描述一类对象的行为和状态。
- 类的成员包括属性、方法、构造器。


### Ⅱ 权限修饰符

声明类、属性、方法时约定使用权限

- **private** : 在同一类内可见。
- **default** (即缺省）: 在同一包内可见，不使用任何修饰符。
- **protected** : 对**同一包内和所有子类**可见。
- **public** : 对所有类可见。

### Ⅲ 类的成员

1. **属性**：
   - 作用：描述类包含的信息。
   - 声明格式：**权限修饰符 数据类型** 变量名 = 变量值;
   - 赋值先后顺序：默认初始化 > 显示初始化 > 构造器赋值 > 对象调用属性或方法赋值。
2. **方法**：
   - 作用：描述类的具有的功能。
   - 声明格式：**权限修饰符 数据类型** 方法名 (**数据类型** 形参1, **数据类型** 形参2, ...) {方法体;}
   - **重载(Overload)**：形参一定不同，方法名相同的方法。
   - Java的方法参数传递机制：当参数为基本数据类型，实参给形参的是实参真实存储的数据值，传递的是值的拷贝，传递后就互不相关；当参数是引用数据类型，实参赋给形参的是实参存储数据的地址值。
3. **构造器**：
   - 作用：创建对象时调用，初始化对象信息。
   - 声明格式：**权限修饰符 数据类型** 类名 (**数据类型** 形参1, **数据类型** 形参2, ...) {方法体;}
   - 一个类中至少有一个构造器，没有显示的定义时，类会默认提供一个空参构造器。当有显示的定义后，便不再默认提供。一个类中可定义多个构造器，彼此构成重载。

## 3、继承

### Ⅰ 概述

- 继承性描述**父类与子类**关系的特性。主要体现为，一旦子类继承了父类，子类就获取了父类中声明的所有属性和方法（包括私有的，且保留了私有性）；子类还能自己声明自己特有的属性和方法，实现功能的扩展。
- 在java中，一个父类可有多个子类，但一个子类只能继承一个父类。一在没有显式的声明一个类的父类，则此类继承于java.lang.Object类。因此，所有java类都直接或间接的继承于java.lang.Object类。
- **作用**：减少代码冗余，便于功能扩展，为多态性的使用提供了前提。

### Ⅱ 方法重写(override)

1. **描述：**

   重写发生在**子类与父类之间, 重写方法与父类中的同名、同参数。**重写以后，通过子类对象调用的是重写的方法。父类对象调用还是原方法。

2. **规则**：

   - **方法名与形参列表**相同。
   - **对于返回值**：当父类方法返回值是**void**或者**基本数据类型**时，必须相同。当是一个类时，则可以是**该类和其子类**。
   - 子类方法的权限修饰符等级 **>=** 父类方法权限（如父方法为public，子方法不能是缺省。**private和final修饰的方法不能**被重写）
   - 子类重写的方法抛出的**异常类型** >= 父类方法抛出的异常类型。


### Ⅲ 子类对象实例化的过程

1. **从结果上来看：**

   - 子类继承父类以后，就获取了父类中声明的属性或方法。
   - 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。

2. **从过程上来看：**

   当通过子类的构造器创建子类对象时，**一定会直接或间接的调用父类的构造器**，直到调用了java.lang.Object类中空参构造器为止，正因为加载过所有的父类结构，所以才可以在内存中看到父类的结构，子类对象才可以考虑调用。

   **明确：**虽然创建子类对象时，调用了父类的构造器，但自始至终就**创建过一个对象**，即为**new的子类对象**。

## 4、多态

### Ⅰ 概述

- 多态性是利用继承关系扩展对象功能的特性。
- **体现**：子类重写父类的方法后，定义父类引用指向子类对象(向上转型)。调用该方法，实际运行时执行的就是子类中的方法。抽象类和接口的实现也体现了多态性。
- **作用**：实现代码的通用性和扩展性，如Object类中的equals方法，可重写实现不同类对象间的比较。
