

# 一、Java基本语法（[BiliBili视频](https://www.bilibili.com/video/BV1Kb411W75N?from=search&seid=3785225082684347697&spm_id_from=333.337.0.0)）

## 1、变量

### Ⅰ 命名规范

| 包名         | 多单词组成时所有字母都小写：xxxyyyzzz                        |
| ------------ | ------------------------------------------------------------ |
| 类名         | 接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz        |
| 变量、方法名 | 多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz |
| 常量名       | 所有字母都大写。多单词时每个单词用下划线连接：XXX YYY ZZZ    |

### Ⅱ 变量初始化

- 变量为**局部变量**时必须先声明，再**初始化值**后使用，否则报错。
- 当变量为类中**成员变量**，实例化对象时会被赋予默认值。
- **数组**对象实例化后，其中**元素**也会被赋予对应类型的默认值。
- **默认值**为：整型为0，浮点型为0.0(f/d)，布尔型为false，字符型为 '/u0000' (空字符，数值为0)，引用类型为NULL。

### **Ⅲ 数据类型**

![202208181615738](https://cdn.jsdelivr.net/gh/mrsenmu/JavaLearningNotes/images/202208190954685.jpeg)

| 类型名称     | 关键字  | 占用内存 | 取值范围                                   |
| ------------ | ------- | -------- | ------------------------------------------ |
| 字节型       | byte    | 1 字节   | -128~127                                   |
| 短整型       | short   | 2 字节   | -32768~32767                               |
| 整型         | int     | 4 字节   | -2147483648~2147483647                     |
| 长整型       | long    | 8 字节   | -9223372036854775808L~9223372036854775807L |
| 单精度浮点型 | float   | 4 字节   | +/-3.4E+38F（6~7 个有效位）                |
| 双精度浮点型 | double  | 8 字节   | +/-1.8E+308 (15 个有效位）                 |
| 字符型       | char    | 2 字节   | ISO 单一字符集                             |
| 布尔型       | boolean | 1 字节   | true 或 false                              |

- 整型：byte、short、int、long。
- 浮点型：java中小数的默认类型位**double**，要定义float型时需定义时末尾加 **f 或 F，**否则 （如float a = 1.1）会报 **不兼容类型错误：**从double转float可能会有损失。
- 字符型（char）：默认值为0或者说'\u0000'(Unicode表示形式，空字符)。
- 布尔型（boolean）：默认false。
- 7种基本数据类型之间的运算（除布尔型boolean）：
  1. **自动类型提升**：
     - **当容量小的数据类型的变量与容量大的做运算时，会自动转换成容量大的数据类型的变量。**
     - 对于(byte、 char、 short) --> int -- > long --> float -- > double，可用表示数据类型范围大的变量去接收范围小的变量，如 (short b = 1；int c = 2；float a = b + c（a为3.0）)**特别的：**当byte、char、short做运算时，结果都是int型。如short a = 1；a = a +1;编译期就会报错，因为a+1的结果是int型，不能赋给short型，需要强转(short)(a+1)，或者**可用++或+=**。
  2. **强制类型转换 ：**
     - 需要使用强转符（）：如float a = 12.9f；int b = (int)a; (截断操作，a的值为12，精度损失)
     - 可能导致精度损失。对于整型，若强转前值没有超范围，不会精度损失。

- 常量默认类型：整数常量默认类型为int，浮点型常量默认为double。
- String类型变量：string可以与8种基本类型做运算，且只能是**连接运算（+）**，结果为string。

## 2、运算

### **Ⅰ 运算符**

算术运算符、位运算符、关系运算符、逻辑运算符、赋值运算符、三元运算符。

### **Ⅱ 算术运算：**

- 算术运算符：+(正) 、-(符)、+、-、*、\、%、++、--、+(连接)。

- **自增++、自减--，不会改变本身数据类型。**

### **Ⅲ 赋值运算**

- 符号：
  - =当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制
    类型转换原则进行处理。
  - 支持连续赋值。
- 扩展赋值运算符：+=，-=，*=，/=，%=。
- **扩展赋值运算符不改变变量本身数据类型。**

### **Ⅳ 关系运算**

表格中的实例整数变量A的值为10，变量B的值为20：

| 运算符 | 描述                                                         | 例子             |
| :----- | :----------------------------------------------------------- | :--------------- |
| ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。         | （A == B）为假。 |
| !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。     | (A != B) 为真。  |
| >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。   | （A> B）为假。   |
| <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。   | （A <B）为真。   |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |

### Ⅴ **逻辑运算**

| &—逻辑与  | \|—逻辑或   | ！—逻辑非  |
| --------- | ----------- | ---------- |
| &&—短路与 | \|\|—短路或 | ^—逻辑异或 |

逻辑(与\或)和短路(与\或)的区别是：**逻辑**的符号两边都会计算再判断；而**短路**的是先左后右，满足条件时可提前跳转。

### **Ⅵ 位运算**

1. 下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：

| 位运算符 |                                                              |                                |
| -------- | ------------------------------------------------------------ | ------------------------------ |
| ＆       | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
| \|       | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
| ^        | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
| 〜       | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
| <<       | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
| >>       | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
| >>>      | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

2. Java中>>和>>>的区别
   - **>>：**带符号右移。**正数右移高位补0，负数右移高位补1**。比如：4 >> 1，结果是2；-4 >> 1，结果是-2。-2 >> 1，结果是-1。
   - **>>>：**无符号右移。无论是正数还是负数，**高位通通补0**。
   - 对于正数而言，>>和>>>没区别。
   - 对于负数而言，-2 **>>>** 1，结果是2147483647（Integer.MAX_VALUE），-1 **>>>** 1，结果是2147483647（Integer.MAX_VALUE）。所以，要判断两个数符号是否相同时，可以这么干：return ((a >> 31) ^ (b >> 31)) == 0;
3. 对于**取反符~**，流程是：**操作数**->**原码**(正数：符号位0；负数：符号位1)->**反码**（正数：不变；负数：原码基础上，符号位不变，其余取反）->**补码**（正数：不变；负数：反码基础上+1）->**补码取反**（包括符号位按位取反）->反码（负数：-1；正数：不变）->原码（负数：除符号位取反；正数：不变）。

### **Ⅶ 三元运算**

1. 语法：

   - expression1 ? expression2 : expression3。

   - `expression1`可以是计算的，值为` boolean `的任何表达式。如果` expression1 `是` true `，那么将评估` expression2 `。否则，将评估` expression3 `。

   - 表达式1和表达式2为同类型。
2. 三元运算符与if-else的的联系与区别：

     1. 三元运算符可简化if-else语句；
     2. 三元运算符要求必须返回一个结果。
     3. if后的代码块可有多个语句。

## 3、流程控制

### **Ⅰ 三种基本流程结构：**

1. 顺序结构：程序从上到下逐行执行，无跳转和判断。

2. 分支结构：if-else、switch-case两种分支语句。

3. while、do-while、for、foreach（jdk5）。

### **Ⅱ **分支结构

- **包括if-else、switch-case。**
- **switch表达式可有类型（6种）：**jdk5以前，byte、short、char、int；jdk5 加入枚举类型（enum），jdk7时支持String（目前不支持long）。
- **case：常量**（数据类型与switch表达式相同，且不能是表达式）。

# 二、数组（Array）

## **1、 理解**

数组是多个相同类型的数据按一定顺序排列的集合，并使用一个名字命名。

## 2、相关概念

1. 数组名

2. 下标（或索引）

3. 元素

4. 数组的长度

## 3、数组的特点

- 数组是**有序**排列的。
- 数组本身是引用数据类型，其中元素可以是基本类型和引用类型。
- 创建数组对象会在内存中开辟一整块连续的空间，而数组名引用的是这块连续空间的首地址。
- 数组**长度**一旦确定，就不能修改。
- 实例化对象后**元素**会被赋予**默认值**。

## 4、初始化创建

1. 静态初始化：初始化时赋值。int[] a = {1,2,3}。
2. 动态初始化：初始化时确定长度。需要后面动态赋值。int[] a = new Int[3] 。

## 5、Arrays工具类（数组操作）

1. 包含大量数组操作的**静态方法**，直接类名调用。
2. 常用方法(以int型数组为例)：
   - **比较**：boolean equals(int[] a, int[] b);
   - **输出**：String toString(int[] a);
   - **填充指定值（将所有元素替换为指定值）**：void fill(int[] a, int val);
   - **排序**：void sort(int[] a);
   - **二分查找**：int binarySearch(int[] a, int key);

# 三、面向对象（上）

## 1、面向过程与面向对象（OOP）

### Ⅰ 区别：

- **面向过程**：强调功能行为，以函数为最小单位，考虑怎么做。
- **面向对象**：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。
- **优缺点：**
  - 面向过程：
    - 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
    - 缺点：没有面向对象易维护、易复用、易扩展。
  - 面向对象：
    - 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。
    - 缺点：性能比面向过程低。

### Ⅱ 面向对象三大特性

1. **封装**。封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
2. **继承**。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。
3. **多态性**。它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。

